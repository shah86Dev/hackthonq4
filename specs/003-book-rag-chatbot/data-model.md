# Data Model: Book-Integrated RAG Chatbot

## Overview
This document defines the data structures and relationships for the Book-Integrated RAG Chatbot system.

## Core Entities

### BookContentChunk
**Description**: A segment of book text that has been processed and embedded for RAG retrieval

**Fields**:
- `chunk_id` (string): Unique identifier for the chunk (UUID)
- `book_id` (string): Reference to the book this chunk belongs to
- `page_number` (integer): Page number in the original book
- `section_title` (string): Title of the section containing this chunk
- `content` (string): The actual text content (500-1000 characters)
- `embedding_vector` (array[float]): 1536-dimensional embedding vector from OpenAI
- `char_start_idx` (integer): Starting character index in the original document
- `char_end_idx` (integer): Ending character index in the original document
- `metadata` (object): Additional metadata like chapter, subsection, etc.
- `created_at` (datetime): Timestamp when the chunk was created
- `updated_at` (datetime): Timestamp when the chunk was last updated

**Validation**:
- `chunk_id` must be unique across all chunks
- `content` length must be between 500-1000 characters
- `embedding_vector` must have exactly 1536 dimensions
- `page_number` must be positive

### BookMetadata
**Description**: Metadata about the book that is being processed

**Fields**:
- `book_id` (string): Unique identifier for the book (UUID)
- `title` (string): Title of the book
- `author` (string): Author of the book
- `isbn` (string): ISBN of the book (if available)
- `total_pages` (integer): Total number of pages in the book
- `word_count` (integer): Total word count in the book
- `language` (string): Language of the book
- `file_path` (string): Path to the original book file
- `processing_status` (string): Current status of processing (e.g., "pending", "processing", "completed", "failed")
- `total_chunks` (integer): Total number of chunks created from this book
- `created_at` (datetime): Timestamp when the book record was created
- `updated_at` (datetime): Timestamp when the record was last updated

**Validation**:
- `book_id` must be unique
- `processing_status` must be one of the allowed values
- `total_pages` and `word_count` must be non-negative

### UserQuery
**Description**: A query submitted by a user to the RAG chatbot

**Fields**:
- `query_id` (string): Unique identifier for the query (UUID)
- `session_id` (string): Reference to the user session
- `user_id` (string): Reference to the user (if authenticated)
- `original_question` (string): The original question from the user
- `selected_text` (string): Text selected by the user in the book viewer (optional)
- `processed_query` (string): Query after preprocessing (for embedding)
- `query_embedding` (array[float]): 1536-dimensional embedding of the query
- `retrieved_chunks` (array[string]): List of chunk IDs that were retrieved
- `retrieval_score_threshold` (float): Threshold used for chunk retrieval
- `top_k_retrieved` (integer): Number of top chunks retrieved (default 5)
- `timestamp` (datetime): When the query was submitted
- `response_time_ms` (integer): Time taken to process the query in milliseconds

**Validation**:
- `query_id` must be unique
- `original_question` must not be empty
- `query_embedding` must have exactly 1536 dimensions

### GeneratedResponse
**Description**: The response generated by the RAG system for a user query

**Fields**:
- `response_id` (string): Unique identifier for the response (UUID)
- `query_id` (string): Reference to the original user query
- `generated_answer` (string): The answer generated by the AI model
- `context_chunks_used` (array[object]): List of chunks used to generate the response with relevance scores
- `model_used` (string): Name of the AI model used (e.g., "gpt-4o")
- `temperature_used` (float): Temperature setting used for generation
- `tokens_used` (integer): Number of tokens used in the generation
- `grounding_confidence` (float): Confidence score that the response is grounded in book content
- `hallucination_detected` (boolean): Whether hallucination was detected in the response
- `citations` (array[object]): Citations to specific chunks/pages in the book
- `timestamp` (datetime): When the response was generated

**Validation**:
- `response_id` must be unique
- `generated_answer` must not be empty
- `grounding_confidence` must be between 0 and 1

### UserSession
**Description**: A session representing a user's interaction with the chatbot

**Fields**:
- `session_id` (string): Unique identifier for the session (UUID)
- `user_id` (string): Reference to the user (if authenticated)
- `session_start` (datetime): When the session started
- `last_activity` (datetime): When the session had its last activity
- `query_count` (integer): Number of queries made in this session
- `session_metadata` (object): Additional session metadata (device, browser, etc.)
- `active_duration_seconds` (integer): Duration of the session in seconds
- `ended_at` (datetime): When the session ended (null if still active)

**Validation**:
- `session_id` must be unique
- `session_start` must be before `last_activity`

### AgentActivityLog
**Description**: Log of activities performed by the different agents in the system

**Fields**:
- `log_id` (string): Unique identifier for the log entry (UUID)
- `agent_type` (string): Type of agent (e.g., "retrieval", "generation", "coordinator")
- `operation` (string): Operation performed (e.g., "retrieve", "generate", "coordinate")
- `session_id` (string): Reference to the session
- `query_id` (string): Reference to the query (if applicable)
- `input_data` (object): Input data passed to the agent
- `output_data` (object): Output data returned by the agent
- `execution_time_ms` (integer): Time taken for the operation
- `success` (boolean): Whether the operation was successful
- `error_message` (string): Error message if operation failed
- `timestamp` (datetime): When the operation occurred

**Validation**:
- `log_id` must be unique
- `agent_type` must be one of the valid agent types
- `success` must be consistent with presence of error_message

### RateLimitLog
**Description**: Log of rate limiting activities to prevent abuse

**Fields**:
- `log_id` (string): Unique identifier for the log entry (UUID)
- `client_ip` (string): IP address of the client
- `user_id` (string): User ID if authenticated (optional)
- `endpoint` (string): API endpoint accessed
- `request_count` (integer): Number of requests in the current window
- `rate_limit_exceeded` (boolean): Whether rate limit was exceeded
- `window_start` (datetime): Start of the rate limiting window
- `window_duration_seconds` (integer): Duration of the rate limiting window
- `timestamp` (datetime): When the request was made

**Validation**:
- `log_id` must be unique
- `rate_limit_exceeded` must be consistent with `request_count` and limits

## Relationships

1. **BookMetadata** → **BookContentChunk**: One-to-many (one book has many chunks)
2. **UserSession** → **UserQuery**: One-to-many (one session has many queries)
3. **UserQuery** → **GeneratedResponse**: One-to-one (one query generates one response)
4. **UserQuery** → **BookContentChunk**: Many-to-many through retrieved_chunks field
5. **UserSession** → **AgentActivityLog**: One-to-many (one session has many agent activities)
6. **UserQuery** → **AgentActivityLog**: One-to-many (one query may trigger multiple agent activities)

## State Transitions

### BookMetadata States
- `pending` → `processing` → (`completed` | `failed`)

### UserSession States
- `active` → `inactive` → `expired`

### UserQuery States
- `received` → `processing` → (`completed` | `failed`)

## Validation Rules

1. All timestamps must be in ISO 8601 format
2. All IDs must follow UUID format or similar globally unique identifier
3. Content fields must be properly sanitized to prevent injection attacks
4. Session history must be limited to prevent excessive memory usage
5. Embedding vectors must have exactly 1536 dimensions (as required by OpenAI ada-002)
6. All responses must be validated for hallucination before being returned to users
7. Rate limiting must be enforced per IP and per authenticated user

## Serialization Format

All data entities will be serialized as JSON objects with consistent field naming using snake_case convention. Sensitive information (like API keys) must be excluded from all serializations.